!(function (a, b) { typeof define === 'function' && define.amd && define.amd.dust === !0 ? define(['dust.core'], b) : typeof exports === 'object' ? (module.exports = b(require('dustjs-linkedin')), module.exports.registerWith = b) : b(a.dust); }(this, (dust) => {
  function a(a, b, c) { c = c || 'INFO', a = a ? `{@${a}}: ` : '', dust.log(a + b, c); } function b(b) { k[b] || (a(b, `Deprecation warning: ${b} is deprecated and will be removed in a future version of dustjs-helpers`, 'WARN'), a(null, `For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#${b.replace(/\W+/g, '')}`, 'WARN'), k[b] = !0); } function c(a) { return a.stack.tail && a.stack.tail.head && typeof a.stack.tail.head.__select__ !== 'undefined'; } function d(a) { return c(a) && a.get('__select__'); } function e(a, b) {
    let c; const d = a.stack.head; const e = a.rebase(); a.stack && a.stack.tail && (e.stack = a.stack.tail); const f = {
      isPending: !1, isResolved: !1, isDeferredComplete: !1, deferreds: [],
    }; for (c in b)f[c] = b[c]; return e.push({ __select__: f }).push(d, a.stack.index, a.stack.of);
  } function f(a) { let b; let c; if (a.isDeferredPending = !0, a.deferreds.length) for (a.isDeferredComplete = !0, b = 0, c = a.deferreds.length; c > b; b++)a.deferreds[b](); a.isDeferredPending = !1; } function g(a, b) {
    return typeof b === 'function' ? b.toString().replace(/(^\s+|\s+$)/gm, '').replace(/\n/gm, '').replace(/,\s*/gm, ', ')
      .replace(/\)\{/gm, ') {') : b;
  } function h(a, b) { return function (c, d, e, f) { return i(c, d, e, f, a, b); }; } function i(b, c, e, f, g, h) { let i; let k; let l; let m; const n = e.block; const o = e.else; const p = d(c) || {}; if (p.isResolved && !p.isDeferredPending) return b; if (f.hasOwnProperty('key'))k = f.key; else { if (!p.hasOwnProperty('key')) return a(g, 'No key specified', 'WARN'), b; k = p.key; } return m = f.type || p.type, k = j(c.resolve(k), m), l = j(c.resolve(f.value), m), h(k, l) ? (p.isPending || (i = !0, p.isPending = !0), n && (b = b.render(n, c)), i && (p.isResolved = !0)) : o && (b = b.render(o, c)), b; } function j(a, b) { switch (b && (b = b.toLowerCase()), b) { case 'number': return +a; case 'string': return String(a); case 'boolean': return a = a === 'false' ? !1 : a, Boolean(a); case 'date': return new Date(a); } return a; } var k = {}; const l = {
    tap(a, c, d) { return b('tap'), d.resolve(a); }, sep(a, b, c) { const d = c.block; return b.stack.index === b.stack.of - 1 ? a : d ? d(a, b) : a; }, first(a, b, c) { return b.stack.index === 0 ? c.block(a, b) : a; }, last(a, b, c) { return b.stack.index === b.stack.of - 1 ? c.block(a, b) : a; }, contextDump(b, c, d, e) { let f; let h; const i = c.resolve(e.to); const j = c.resolve(e.key); switch (j) { case 'full': f = c.stack; break; default: f = c.stack.head; } switch (h = JSON.stringify(f, g, 2), i) { case 'console': a('contextDump', h); break; default: h = h.replace(/</g, '\\u003c'), b = b.write(h); } return b; }, math(b, c, g, h) { let i; let j = h.key; const k = h.method; let l = h.operand; const m = h.round; if (!h.hasOwnProperty('key') || !h.method) return a('math', '`key` or `method` was not provided', 'ERROR'), b; switch (j = parseFloat(c.resolve(j)), l = parseFloat(c.resolve(l)), k) { case 'mod': l === 0 && a('math', 'Division by 0', 'ERROR'), i = j % l; break; case 'add': i = j + l; break; case 'subtract': i = j - l; break; case 'multiply': i = j * l; break; case 'divide': l === 0 && a('math', 'Division by 0', 'ERROR'), i = j / l; break; case 'ceil': case 'floor': case 'round': case 'abs': i = Math[k](j); break; case 'toint': i = parseInt(j, 10); break; default: a('math', `Method \`${k}\` is not supported`, 'ERROR'); } return typeof i !== 'undefined' && (m && (i = Math.round(i)), g && g.block ? (c = e(c, { key: i }), b = b.render(g.block, c), f(d(c))) : b = b.write(i)), b; }, select(b, c, g, h) { const i = g.block; const j = {}; return h.hasOwnProperty('key') && (j.key = c.resolve(h.key)), h.hasOwnProperty('type') && (j.type = h.type), i ? (c = e(c, j), b = b.render(i, c), f(d(c))) : a('select', 'Missing body block', 'WARN'), b; }, eq: h('eq', (a, b) => a === b), ne: h('ne', (a, b) => a !== b), lt: h('lt', (a, b) => b > a), lte: h('lte', (a, b) => b >= a), gt: h('gt', (a, b) => a > b), gte: h('gte', (a, b) => a >= b), any(b, c, e) { const f = d(c); return f ? f.isDeferredComplete ? a('any', 'Must not be nested inside {@any} or {@none} block', 'ERROR') : b = b.map((a) => { f.deferreds.push(() => { f.isResolved && (a = a.render(e.block, c)), a.end(); }); }) : a('any', 'Must be used inside a {@select} block', 'ERROR'), b; }, none(b, c, e) { const f = d(c); return f ? f.isDeferredComplete ? a('none', 'Must not be nested inside {@any} or {@none} block', 'ERROR') : b = b.map((a) => { f.deferreds.push(() => { f.isResolved || (a = a.render(e.block, c)), a.end(); }); }) : a('none', 'Must be used inside a {@select} block', 'ERROR'), b; }, size(a, b, c, d) { let e; let f; let g = d.key; if (g = b.resolve(d.key), g && g !== !0) if (dust.isArray(g))e = g.length; else if (!isNaN(parseFloat(g)) && isFinite(g))e = g; else if (typeof g === 'object') { e = 0; for (f in g)g.hasOwnProperty(f) && e++; } else e = (`${g}`).length; else e = 0; return a.write(e); },
  }; for (const m in l)dust.helpers[m] = l[m]; return dust;
}));
