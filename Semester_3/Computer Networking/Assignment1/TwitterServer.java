import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 *  An Abstract class which handles all the threads generated by the Server application
 * @author Alessandro Romanelli
 * @version 1.0
 */
abstract class DynamicThreadPool {
    /**
     * The set of ServerThreads that are currently alive
     */
    final static private HashSet<TwitterServerThread> pool = new HashSet<>();
    /**
     * The desireable amount of threads of the pool
     */
    static private int targetSize = 4;
    /**
     * The number of threads with an established connection
     */
    static int activeThreads = 0;

    /**
     * The main method which will monitor the ServerThreads dedicated to handling inbound connections.
     */
    static public void monitor() {
        while (true) {
            // Create as many threads as our current target and initialise them
            while (pool.size() < targetSize) {
                TwitterServerThread t = new TwitterServerThread();
                addThread(t);
                new Thread(t).start();
            }

            // For each existing thread
            for (Iterator<TwitterServerThread> iterator = pool.iterator(); iterator.hasNext(); ) {
                TwitterServerThread t = iterator.next();
                Socket s = t.getCurrentSocket();
                // If socket is not null
                if (s != null) {
                    // Kill the thread only if the socket is closed and we are overshooting the desired size
                    if (s.isClosed() && pool.size() > targetSize) {
                        t.kill();
                        iterator.remove();
                    }
                } else {
                    // If the socket is null, there's no ongoing connection
                    if (pool.size() > targetSize) {
                        t.kill();
                        iterator.remove();
                    }
                }
            }

            // If the active threads are closing in on the number of available threads
            if (activeThreads > pool.size()*0.75) {
                // Double the amount of available threads
                targetSize *= 2;
            }

            // If the active threads are less than the split threshold
            while ((activeThreads < (pool.size()/2)*0.75) && targetSize > 4) {
                // Half the amount of available threads
                targetSize /= 2;
            }

            try {
                // Fire once per second
                Thread.sleep(1000);
            } catch (InterruptedException ex) {}
        }
    }

    /**
     * A method which takes a TwitterServerThread and adds it to the set of alive threads
     * @param t The thread to be added to the set
     */
    static private void addThread(TwitterServerThread t) {
        pool.add(t);
    }

    static synchronized public void incrementActiveThreads() {
        activeThreads++;
    }

    static synchronized public void decreaseActiveThreads() {
        activeThreads--;
    }

}

/**
*   Implementation of a Thread which handles a single connection coming from a client
*   @author Alessandro Romanelli
*   @version 1.0
 */
class TwitterServerThread implements Runnable {
    private volatile boolean isRunning = true;
    /**
     * Our current connection with the client
     */
    private Socket current_socket;

    /**
     * Method invoked when starting a ServerThread
     * Attempts to establish a connection as long as the server socket
     * is open and handles input and output channels of any new connection.
     */
    public void run() {
        try {
            final ServerSocket srv_socket = TwitterServer.getSocket();
            // Flag to keep the thread alive
            while(isRunning) {
                // Set a timeout on listening for incoming connection to avoid blocking
                srv_socket.setSoTimeout(1000);
                try {
                    // Accepts a new connection or waits for an incoming one
                    current_socket = srv_socket.accept();
                    // Increment the number of active threads in the ThreadPool after connection established
                    DynamicThreadPool.incrementActiveThreads();
                    // Setup the input channel
                    final InputStream input = current_socket.getInputStream();
                    final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
                    String line;
                    try {
                        // Until our line isn't null or an exception is thrown
                        while ((line = reader.readLine()) != null) {
                            // Process the message sent by the client
                            processInput(line);
                        }
                    } catch (IOException ex) {
//                    System.err.println("Exception: "+ex);
                    }
                    // When we quit our read input loop, unsubscribe the client's
                    // connection from the current subscriptions
                    TwitterServer.unsubscribeSocket(current_socket);
                    // Close the connection
                    current_socket.close();
                    current_socket = null;
                    // Decrease the number of active threads
                    DynamicThreadPool.decreaseActiveThreads();
                } catch (SocketTimeoutException ex) {
//                    System.err.println("Timeout");
                };
            }
        } catch (IOException ex) {
//            System.err.println("Exception: "+ex);
        }
    }

    /**
     * A getter for the current connection's socket
     * @return The socket of the current connection or null if a connection isn't established
     */
    public Socket getCurrentSocket() {
        return current_socket;
    }

    /**
     * A method which kills the Thread on which this method is invoked
     */
    public void kill() {
        isRunning = false;
    }
    /**
     * Processes the string sent from the Client to the Server
     * Operates depending on the VERB of the line passed to the method.
     * @param line A string in the following format: VERB PAYLOAD
     */
    private void processInput(String line) {
        // Takes the first word and stores it in uppercase (Case Insensitivity)
        final String verb = line.split(" ", 2)[0].toUpperCase();

        String payload = line.split(" ", 2)[1];

        // Handle the PAYLOAD depending on the VERB
        if (verb.equals("TWEET")) {
            // TWEET <message + hashtags>

            // Create an empty set of hashtags
            HashSet<String> tags = new HashSet<>();
            Pattern pattern = Pattern.compile("\\B(#[a-zA-Z]+\\b)");
            Matcher matcher = pattern.matcher(payload);
            // Find all hashtags within the payload and add them to our set of hashtags
            while (matcher.find()) {
                tags.add(matcher.group());
            }
            // Print the message of the tweet to the Server console
            print(payload);
            // Broadcast the tweet to the relative tags
            broadcastTweet(tags, payload);

        } else if (verb.toUpperCase().equals("SUBSCRIBE")) {
            // SUBSCRIBE <hashtag>
            final String hashtag = payload.split(" ", 2)[0];
            // Register the client connection which subscribe to the given hashtag
            TwitterServer.registerSubscription(hashtag, current_socket);

        } else if (verb.equals("UNSUBSCRIBE")) {
            // UNSUBSCRIBE <hashtag>
           final String hashtag = payload.split(" ", 2)[0];
           // Delete the client connection which unsubscribed from the given hashtag
           TwitterServer.unregisterSubscription(hashtag, current_socket);

        }
    }

    /**
     * (Synchronized Method)
     * Sends the given message to all the connections which are subscribed to any of the provided hashtags
     * Only one thread might broadcast at a time
     * @param tags A set of hashtags
     * @param message The message to be sent
     */
    private synchronized void broadcastTweet(HashSet<String> tags, String message) {
        // A new set of Sockets
        final HashSet<Socket> sockets = new HashSet<>();
        // Add to our new set all the sockets associated to each tag
        for (String hashtag: tags) {
            try {
                synchronized (TwitterServer.getSubscriptions()) {
                    sockets.addAll(TwitterServer.getSubscriptions().get(hashtag));
                }
            } catch (NullPointerException ex) {
//                System.err.println("Tweet broadcasted without any subscription: "+ex);
            }
            // Remove the current connection which sent the message
            sockets.remove(current_socket);
        }
        // For each of the socket of our set
        for (Socket s: sockets) {
            try {
                OutputStream output = s.getOutputStream();
                // Write the message to the output channel
                output.write((message+"\n").getBytes());
            } catch (IOException ex) {
//                System.err.println("Exception :"+ex);
            }
        }
    }

    /**
     * (Synchronized Method)
     * Outputs the message to the Server's console. Only one thread may write at a time.
     * @param message The message to be printed on the console
     */
    private synchronized void print(String message) {
        System.out.println(message);
    }
}

/**
 *   Abstract class for a Server which instantiates a fixed amount of threads
 *   and handles the subscriptions of Sockets to Hashtags
 *   @author Alessandro Romanelli
 *   @version 1.0
 */
abstract public class TwitterServer {
    /**
     * The hashmap of subscriptions, which maps from Hashtag to a set of Sockets
     */
    private static HashMap<String, HashSet<Socket>> subscriptions = new HashMap<>();
    /**
     * The Server socket which handles all the connections coming from and to the clients
     */
    private static ServerSocket socket;

    /**
     * Main method of the Server application which initialises the ServerThreads
     * @param args The arguments for the main method: LISTEN_PORT
     */
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: ./server LISTEN_PORT");
            System.exit(1);
        }

        int listen_port = Integer.parseInt(args[0]);


        try {
            // Attempts to open the port to listen for incoming connections
            socket = new ServerSocket(listen_port);
        } catch (IOException ex) {
//            System.err.println("Exception: "+ex);
        }

        // Adds a shutdown hook, which is a Thread instantiated by a lambda function
        // which fires when the application is shutdown
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                // Close the server socket
                socket.close();
            } catch (IOException ex) {
//                System.err.println("Exception: "+ex);
            }
            // Print a good bye message
//            System.out.println("Shutting down server");
        }));

        DynamicThreadPool.monitor();
    }

    /**
     * A getter for the static field of subscriptions
     * @return An hashmap of subscriptions, which maps a hashtag to the connections subscribed to it
     */
    static HashMap<String, HashSet<Socket>> getSubscriptions() {
        return subscriptions;
    }

    /**
     * A getter for the server socket of our application
     * @return The server socket on which our application is listening
     */
    static ServerSocket getSocket() {
        return socket;
    }

    /**
     * A setter for the subscriptions, which adds the passed socket to the set of subscribed connections to the given hashtag
     * @param hashtag The hashtag that we are going to register our socket to
     * @param s The socket that will be registered to the hashtag
     */
    static synchronized void registerSubscription(String hashtag, Socket s) {
        // An uninitialised set of sockets
        HashSet<Socket> sockets;
        if (subscriptions.containsKey(hashtag)) {
            // Get the set which contains the connections associated to the given hashtag
            sockets = subscriptions.get(hashtag);
            // Add the socket to be registered to that set
            sockets.add(s);

        } else {
            // Create a new entry
            sockets = new HashSet<>();
            sockets.add(s);
            subscriptions.put(hashtag, sockets);
        }
    }

    /**
     * A setter for the subscriptions, which removes a socket from the set of subscribed connections to the given hashtag
     * @param hashtag The hashtag that we are going to unregister our socket from
     * @param s The socket that will be unregistered from the hashtag
     */
    static synchronized void unregisterSubscription(String hashtag, Socket s) {
        if (subscriptions.containsKey(hashtag)) {
            // Get the set of connections for the given hashtag and remove the socket from it
            subscriptions.get(hashtag).remove(s);
        }
    }

    /**
     * A setter for the subscriptions, which removes a socket from any set of subscribed connection to any hashtag
     * @param s The socket that will be unregistered from all hashtags
     */
    static synchronized void unsubscribeSocket(Socket s) {
        // Get the set of hashtags of the hashmap
        Set<String> tags = subscriptions.keySet();
        for (String hashtag : tags) {
            // Remove the socket from each hashtag
            subscriptions.get(hashtag).remove(s);
        }
    }

}